% Exam helper
% 
% by Adam Wilson
%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
% 
\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\ProvidesPackage{asy_helper}
  [2016/09/30 v0.1 Package to provide commonly used asymptote functions.]
  
\RequirePackage[inline]{asymptote}

\begin{asydef}
import graph;
import fontsize;
import slopefield;
defaultpen(fontsize(9pt));
ngraph=1000;
\end{asydef}

% generate isoclines
\begin{asydef}
guide[] isocline(real f(real), real yp(real, real), real min_t, real max_t, int n=10, real width=-1)
{
	if (min_t == max_t)
		return null;
		
	// max sure min_t < max_t
	if (max_t < min_t)
	{
		real tmp = max_t;
		max_t = min_t;
		min_t = tmp;
	}
	
	// size of t-values
	real size=max_t - min_t;
	
	// default width
	if (width < 0)
		width = size/n * 0.5;
		
	guide[] guides;	
	
	// break the domain in into n intervals of equal length along the curve
	real[] tvals;
	guide curve = graph(f, min_t, max_t);
	
	for(int i = 0; i <= n; ++i)
	{
		real l = ((real) i)/((real) n);
		pair p = relpoint(curve, l);
		tvals.push(p.x);
	}

	// draw tangent line segments
	for (real t : tvals)
	{
		real m = yp(t, f(t));
		real t_0 = t;
		real y_0 = f(t);
		
		real tangent(real t) { return m*(t - t_0) + y_0; }
		
		real D = width/2;
		
		real t_1 = t_0 + sqrt(D*D/(m*m+1));
		real t_2 = t_0 - sqrt(D*D/(m*m+1));
		
		//write("t_1 = " + string(t_1));
		//write("t_2 = " + string(t_1));
		
		guide g = graph(tangent, t_1, t_2);
		guides.push(g);
	}
	return guides;
}
\end{asydef}

% graphing helper functions
\begin{asydef}
int pen_pos=-1;
pen[] pens={blue, red, heavycyan, heavymagenta, lightolive};
pens.cyclic=true;
pen next_color() {return pens[++pen_pos];}
void reset_color() {pen_pos = -1;}

DefaultHead.size=new real(pen p=currentpen) {return 2.5mm;};

void draw_grid_lines(real min_x, real max_x, real min_y, real max_y)
{
for(real gx=min_x+1; gx<=max_x-1; ++gx)
	draw((gx,min_y)--(gx,max_y),dotted+darkgray);
    
for(real gy=min_y+1; gy<=max_y-1; ++gy)
	draw((min_x,gy)--(max_x,gy),dotted+darkgray);
}
\end{asydef}

% functions to draw triangles
\begin{asydef}
// draw a label that consists of '$var=val' at pos.
// val is rounded to two decimal places
void vlabel(string var, real val, pair pos)
{
	label("$" + var + "=" + string(round(val*100)/100) + "$", pos, UnFill());
}

// draw a ASS triangle
void draw_ass_triangle(real alpha, real a, real b, bool answers=false)
{
    // calc the remaining values
    real beta = asin((b/a)*sin(alpha));
    real gamma = pi-alpha-beta;
    real c = sqrt(a*a+b*b-2*a*b*cos(gamma));
    real b_x = b*cos(alpha);
    real b_y = b*sin(alpha);
    
    // pens
    pen p = black+1bp;
    pen pdash = lightgrey + 1bp;//black + dotted +1bp;
    
    if (answers)
    	pdash = p;
    
    real r = 0.2*c;
    
    // calculate the arc offsets
    real beta_s = 180;
    real beta_e = beta_s-degrees(beta);
    real gamma_s = degrees(pi+alpha);
    real gamma_e = gamma_s+degrees(gamma);
    
    // draw the angle arcs
    draw(arc((0,0), r, 0, degrees(alpha)), p); 
    draw(arc((b_x,b_y), r, gamma_s, gamma_e), pdash); 
    draw(arc((c,0), r, beta_s, beta_e), pdash);
    
    // draw the sides
    draw((0,0) -- (c,0), pdash);
    draw((0,0) -- (b_x, b_y), p);
    draw((b_x, b_y) -- (c, 0), p);
    
    // draw the labels
    if (answers)
    {
    	real rl = 0.2+r;
	    vlabel("\alpha", alpha, (rl*cos(alpha/2),rl*sin(alpha/2)));
	    vlabel("\beta", beta, (c+rl*-1*cos(beta/2), rl*sin(beta/2)));
	    vlabel("\gamma", gamma, (b_x+rl*cos(pi+alpha+gamma/2), b_y+rl*sin(pi+alpha+gamma/2)));
	    vlabel("a", a, ((b_x+c)/2+0.45,b_y/2));
	    vlabel("b", b, (b_x/2-0.45,b_y/2));
	    vlabel("c", c, (c/2,-0.2));
	}
	else
	{
		real rl = 0.2+r;
		label("$\alpha$", (rl*cos(alpha/2),rl*sin(alpha/2)));
	    label("$\beta$", (c+rl*-1*cos(beta/2), rl*sin(beta/2)));
	    label("$\gamma$", (b_x+rl*cos(pi+alpha+gamma/2), b_y+rl*sin(pi+alpha+gamma/2)));
	   	label("$a$", ((b_x+c)/2+0.2,b_y/2));
	    label("$b$", (b_x/2-0.2,b_y/2));
	    label("$c$", (c/2,-0.2));
	}
}

void draw_polar_axes(int r_a, int r_b)
{
	pen p = mediumgrey + 1bp;
	for(int r = r_a; r <= r_b; ++r)
	{
		draw(circle((0,0), r), p);
	}
	
	real[] angles = {0, pi/6, pi/4, pi/3, pi/2, 2pi/3, 3pi/4, 5pi/6};
	for(real a: angles)
	{
		draw((-r_b*cos(a),-r_b*sin(a)) -- (r_b*cos(a),r_b*sin(a)), p);
	}
}
\end{asydef}
\endinput
