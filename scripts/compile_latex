#!/bin/bash
# Written by Adam Wilson
# wrapper for pdflatex and asy

# directory to hold files generated by LaTeX/Asymptote
working_dir=".auxiliary"

# valid file types
file_extensions=(tex)

# add any additional search paths here (don't escape spaces) (keep the :: at the very end)
export TEXINPUTS="$HOME/LaTeX/packages/::"

# set the command line options for the programs invoked in this script
chkcmd=(chktex -l "$HOME/LaTeX/scripts/.chktexrc" -q)
texcmd=(pdflatex -shell-escape -synctex=1 -halt-on-error -interaction=nonstopmode -output-directory "$working_dir")
dftcmd=(pdflatex -draft -shell-escape -synctex=1 -halt-on-error -interaction=nonstopmode -output-directory "$working_dir")
asycmd=(asy -q)
gnuls=(gls)

# attempt to set banner width to the width of the (interactive) terminal
banner_width=70
if tput cols > /dev/null 2>&1
then
	banner_width="$(tput cols)"
fi

# make alternate stdout and stderr for required output
# add "1>&3 2>&4" for commands that always display output
exec 3>&1
exec 4>&2

# various flags
# 1 = true, 0=false
rebuild_from_scratch=0
do_syntax_check=1
pause_on_warnings=1
halt_on_warnings=0
verbose=1


filename=""
name=""

# usage information
function print_help
{
        echo "Usage: $(basename "$(test -L "$0" && readlink "$0" || echo "$0")") [OPTIONS] FILE"
        echo
        echo "Script to compile LaTeX intelligently."
	echo "  * Will remove any auxiliary problematic files."
	echo "  * All but the last pass is made in draft mode, so only the finished PDF is made."
	echo "  * Will process any Asymptote files generated."
	echo "  * Will ensure enough passes are made to correctly resolve refrences."
        echo
        echo "Options:"
	echo "  -h Print this message"
	echo "  -q Quiet mode."
	if ((syntax_check))
	then
		echo "  -s Skip the syntax check before compiling."
	else
		echo "  -s Run a syntax check before compiling."
	fi
	if ((pause_on_warnings))
	then
		echo "  -p Do not pause on syntax warnings"
	else
		echo "  -p Pause on syntax warnings"
	fi
	if ((halt_on_warnings))
	then
		echo "  -H Do not halt on syntax warnings"
	else
		echo "  -H Halt on syntax warnings"
	fi
	if ((rebuild_from_scratch))
	then
		echo "  -R Do not delete any old auxiliary files."
	else
		echo "  -R Rebuild from scratch. Delete all old auxiliary files."
	fi
	
}


# check that the file passed is of an accepted type
# $1 = filename
function check_file_type
{
	ext="${1##*.}"

	for fe in "${file_extensions[@]}"
	do
		if [ "$ext" == "$fe" ]
		then
			return 0
		fi
	done

	return 1
}

# draw a banner
# $1 = length of banner
# $2 = text to print in center of banner
function draw_banner
{
	dash="-"

	# if an empty string is passed, then we need all dashes
	if [ "$2" == "" ]
	then
		text=""
	else
		text=" $2 "
	fi

	width=$(($1 + ($1 % 2)))

	length="${#text}"

	# build the dashes
	dash_count=$((($width - $length - ($length % 2))/2))
	dashes=$(printf %"$dash_count"s |tr " " "$dash")


	# if the string has an odd length, tack on an extra dash
	if [ "$(($length % 2))" == "0" ]
	then
		echo "$dashes$text$dashes"
	else
		echo "$dashes$text$dashes$dash"
	fi
}

# run the tex program
# if $1 = "draft" no pdf will be produced
function run_tex
{
	# workaround for asymptote not working with pdflatex's -output-directory command
	cp "$working_dir"/"$name"-* ./ 2>/dev/null
	
	if [ "$1" == "draft" ]
	then
		draw_banner "$banner_width" "Start (Draft) LaTeX"

		"${dftcmd[@]}" "$filename"

		return_code=$?

		draw_banner "$banner_width" "End (Draft) LaTeX"
		echo
	else
		draw_banner "$banner_width" "Start LaTeX"

		"${texcmd[@]}" "$filename"

		return_code=$?

		cp "$working_dir"/"$name".pdf ./
		cp "$working_dir"/"$name".synctex.gz ./

		draw_banner "$banner_width" "End LaTeX"
		echo
	fi

	# workaround for asymptote not working with pdflatex's -output-directory command
	rm "$name"-* 2>/dev/null

	return $return_code
}

# process any asymptote files
# return >0 if any files processed
function run_asy
{
	draw_banner "$banner_width" "Start Asymptote"

	old_dir=$(pwd)
	cd "$working_dir"
	
	count=0
	for f in $("${gnuls[@]}" "-1v" "$name"-*.asy 2> /dev/null)
	do
		if [ -e "$f.old" ]
		then
			diff "$f" "$f.old" 2>&1 >/dev/null
			if [ "$?" = "0" ]
			then
				echo "Unaffected: $f"
				continue
			fi
		fi

		echo "Processing: $f"
		output=$("${asycmd[@]}" "$f" 2>&1 >/dev/null)

		if [ "$output" != "" ]
		then
			echo "$output"
			exit 1
		fi

		cp "$f" "$f.old"
		
		count=$((count+1))
	done

	cd "$old_dir"
	
	draw_banner "$banner_width" "End Asymptote"
	echo

	return 1
}

# removes any auxilary files from the last run
function remove_old_files
{
	draw_banner "$banner_width" "Removing Files"

	old_dir=$(pwd)
	cd "$working_dir"
	for f in $("${gnuls[@]}" "-1v" "$name".nav "$name".out "$name".snm "$name".toc "$name".vrb "$name".pre "$name".pdf "$name".aux "$name".log "$name".dvi "$name".fls "$name".synctex.gz "$name"-* 2> /dev/null)
	do
		if [ -f "$f" ]
		then
			echo "Removing $f"
			rm "$f"
		fi
	done
	cd "$old_dir"

	draw_banner "$banner_width" ""
	echo
}

# run a syntax check
function syntax_check
{
	retval=0
	
	if ((do_syntax_check))
	then
		draw_banner "$banner_width" "Syntax Warnings"
		
		output=$("${chkcmd[@]}" "$filename" 2>/dev/null)
		echo "$output"

		draw_banner "$banner_width" ""
		echo

		if [ "$output" != "" ]
		then
			retval=1
			
			# see if we need to pause on syntax warnings
			if ((pause_on_warnings * verbose * (1-halt_on_warnings)))
			then
				echo "Press enter to continue" 1>&3 2>&4
				read -n1 -rs
				echo
			fi
		fi	
	fi
	
	return $retval
}

function show_time ()
{
	local T=$1
	local D=$((T/60/60/24))
	local H=$((T/60/60%24))
	local M=$((T/60%60))
	local S=$((T%60))
	[[ $D > 0 ]] && printf '%d days ' $D
	[[ $H > 0 ]] && printf '%d hours ' $H
	[[ $M > 0 ]] && printf '%d minutes ' $M
	[[ $D > 0 || $H > 0 || $M > 0 ]] && printf 'and '
	printf '%d seconds\n' $S
}

#------------------------#
# Script Execution Start #
#------------------------#


# handle any commandline options
OPTIND=1         # Reset in case getopts has been used previously in the shell.

while getopts "hsqHR" opt; do
	case "$opt" in
	h)
		print_help
		exit
		;;
	s)
		do_syntax_check=$((1-$do_syntax_check))
		;;
	p)
		pause_on_warnings=$((1-$pause_on_warnings))
		;;
	H)
		halt_on_warnings=$((1-$halt_on_warnings))
		;;
	q)
		verbose=$((1-$verbose))
		;;
	R)	rebuild_from_scratch=$((1-$rebuild_from_scratch))
		;;
	*)
		print_help
		exit 1
		;;
	esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

if [ $# -eq 0 ]
then
	print_help
	exit 1
fi

# if we are not being verbose, silence stdout
if ((1-verbose))
then
	exec 1>/dev/null
	#exec 2>/dev/null
fi

# extract filename
filename="$1"
name="${filename%.*}"

# check file type
check_file_type "$filename"
if [ "$?" != "0" ]
then
	echo "Invalid file type: $filename" 1>&3 2>&4
	exit 1
fi

# ensure the working directory exits
mkdir -p "$working_dir"

# start with a basic syntax check to catch obvious errors
syntax_check
if ((halt_on_warnings * $?))
then
	exit 1
fi

# get start time
start=$(date +%s)

# clean up any old intermediate files that may cause trouble
if ((rebuild_from_scratch))
then
	remove_old_files
fi

# make the first run a draft, since we will run again
# it's common for asympotote to have trouble, so run again before giving up
run_tex "draft" || run_tex "draft" || exit 1

# process any asymptote files generated, running the tex again if needed
run_asy && run_tex "draft"

# run one last time to generate the PDF
run_tex

#get end time
end=$(date +%s)

# print compile time
diff=$(echo "$end - $start" | bc)

# display the time
draw_banner "$banner_width" "Duration"
show_time "$diff"
draw_banner "$banner_width" ""
